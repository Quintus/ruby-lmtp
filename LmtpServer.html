<!DOCTYPE HTML>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="stylesheets/rdoc.css"/>
    <script src="javascripts/jquery.js"></script>
    <script src="javascripts/functions.js"></script>
    <script src="javascripts/emerald.js"></script>
    <title>LmtpServer</title>
  </head>
  <body>
    <div id="sidebar">
      <form id="search">
        <p><input type="text" placeholder="Regexp Search"/></p>
      </form>

      <div id="indices">
        <div class="index" id="file-index">
          <div class="header">
            <p>File Index</p>
          </div>

          <div class="list">
            <ul>
              
                
                
                  
                  <li class="code-file" style="display: none"><a href="LICENSE.html">LICENSE</a></li>
                
              
                
                
                  <li class="rdoc-file"><a href="README_rdoc.html">README.rdoc</a></li>
                
              
                
                
                  
                  <li class="code-file" style="display: none"><a href="lib/lmtp_rb.html">lmtp.rb</a></li>
                
              
              <li><a style="font-style: italic" id="toggle-all-files" href="#">Show all</a></li>
            </ul>
          </div>
        </div>

        <div class="index" id="class-index">
          <div class="header">
            <p>Class Index</p>
          </div>

          <div class="list">
            <ul>
              
                <li>
                  <a href="LmtpServer.html">LmtpServer</a>
                </li>
              
            </ul>
          </div>
        </div>

        <div class="index" id="method-index">
          <div class="header">
            <p>Method Index</p>
          </div>

          <div class="list">
            <ul>
              
                <li><a href="LmtpServer.html#method-c-new">::new</a>&nbsp;<span class="method-classname">(LmtpServer)</span></li>
              
                <li><a href="LmtpServer.html#method-i-headers">#headers</a>&nbsp;<span class="method-classname">(LmtpServer)</span></li>
              
                <li><a href="LmtpServer.html#method-i-logging">#logging</a>&nbsp;<span class="method-classname">(LmtpServer)</span></li>
              
                <li><a href="LmtpServer.html#method-i-start">#start</a>&nbsp;<span class="method-classname">(LmtpServer)</span></li>
              
                <li><a href="LmtpServer.html#method-i-stop">#stop</a>&nbsp;<span class="method-classname">(LmtpServer)</span></li>
              
            </ul>
          </div>
        </div>
      </div>
    </div>

    <div id="content">
      

  <h1 class="classmodule"><span class="leader">Class</span> LmtpServer</h1>
  <p class="superclass">
    
    
      Parent: Object
    
  </p>




  <div class="method-overview">
    <p>Method List</p>
    <ul>
      
        <li>
          <a href="#method-c-new">::new</a>
        </li>
      
        <li>
          <a href="#method-i-headers">#headers</a>
        </li>
      
        <li>
          <a href="#method-i-logging">#logging</a>
        </li>
      
        <li>
          <a href="#method-i-start">#start</a>
        </li>
      
        <li>
          <a href="#method-i-stop">#stop</a>
        </li>
      
    </ul>
  </div>




<p>LMTP server class. Instances of this class utilize a UNIX socket to
implement the LMTP protocol (see <a
href="https://tools.ietf.org/html/rfc1854">RFC 2033</a>) in its most
minimal and basic form. LMTP is spoken by possibly any MTA, so using this
class you can make your Ruby program an email endpoint as long as you know
how to configure your MTA. I’ve only tested with Postfix, though, so no
guarantees.</p>

<p>Instances of this class support several callbacks. The main callback is the
message callback, which is passed the the block to <a
href="LmtpServer.html#method-c-new">::new</a>. It gets called whenever the
LMTP client hands in an email, and receives the entire email as plain text
as its argument. You can use the “mail” library or other means to parse it.
Other callbacks you might find useful can be set with the <a
href="LmtpServer.html#method-i-logging">logging</a> and <a
href="LmtpServer.html#method-i-headers">headers</a> methods.</p>

<p>This class makes no use of threads for multiple connections. Thus, any
emails submitted at once to the UNIX domain socket are processed
ony-by-one. A single client could block all other clients thus, but because
LMTP should only ever be used in a completely trusted environment (see RFC
2033, sections 3 and 5), this is not an issue.</p>

<p>It <em>does</em> employ a mutex for the <a
href="LmtpServer.html#method-i-stop">stop</a> method and the checking of
the stopping variable. This means you can safely call <a
href="LmtpServer.html#method-i-stop">stop</a> from another thread.</p>

<p>Example use:</p>

<pre class="ruby"><span class="ruby-identifier">server</span> = <span class="ruby-constant">LmtpServer</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;/var/spool/postfix/private/mysocket&quot;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">message</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;--- Start of email ---&quot;</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-identifier">message</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;--- End of email ---&quot;</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">server</span>.<span class="ruby-identifier">logging</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">level</span>, <span class="ruby-identifier">msg</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">$stderr</span>.<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;[#{level}] #{msg}&quot;</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">server</span>.<span class="ruby-identifier">start</span>
</pre>

<p>The LMTP server by this class implements the following SMTP Service
Extensions (see below for the list of RFCs). Do not implement them yourself
by utilising <a
href="LmtpServer.html#attribute-i-moreextensions">moreextensions</a> and
the callbacks, they’re there already!</p>
<ul><li>
<p>PIPELINING</p>
</li><li>
<p>ENHANCEDSTATUSCODES</p>
</li><li>
<p>8BITMIME</p>
</li></ul>

<p>RFCs implemented by this class:</p>
<ul><li>
<p><a href="https://tools.ietf.org/html/rfc2033">RFC 2033</a></p>
</li><li>
<p><a href="https://tools.ietf.org/html/rfc2034">RFC 2034</a></p>
</li><li>
<p><a href="https://tools.ietf.org/html/rfc1854">RFC 1854</a></p>
</li><li>
<p><a href="https://tools.ietf.org/html/rfc1869">RFC 1869</a></p>
</li><li>
<p><a href="https://tools.ietf.org/html/rfc1652">RFC 1652</a></p>
</li><li>
<p><a href="https://tools.ietf.org/html/rfc821">RFC 821</a> for the minimally
required parts</p>
</li></ul>

<div class="clear"><!-- Long method lists shouldn't hang into the remaining docs --></div>






  <h2 id="constants">Constants</h2>
  <table class="constants">
    <tr><th>Name</th><th>Value</th><th>Description</th></tr>
    
      
      <tr><td>HOSTNAME_FILE</td><td style="font-family: monospace; text-align: center">"/etc/hostname".free...</td><td>
<p>The machine’s hostname is read from this file.</p>
</td></tr>
    
      
      <tr><td>VERSION</td><td style="font-family: monospace; text-align: center">"0.0.1".freeze</td><td>
<p>Version of this library.</p>
</td></tr>
    
  </table>




  <h2 id="attributes">Attributes</h2>
  <ul class="attribute-list" style="list-style-image: url('images/tag_blue.png')">
    
      <li><strong>timeout&nbsp;<sup>[RW]</sup></strong><br/>
<p>Timeout in seconds when a client is forcibly disconnected when it does
nothing.</p>
</li>
    
      <li><strong>moreextensions&nbsp;<sup>[RW]</sup></strong><br/>
<p>This is an array of extra extensions that are announced to the client in
response to LHLO. Just append the names of the extensions to this array
(e.g. “MYCOOLEXTENSION”). The class will take care to prefix is with the
proper LMTP reply code.</p>

<p>This array is empty by default. Modifying it only makes sense if you
actually implement the extensions you advertise here.</p>
</li>
    
      <li><strong>successmsg&nbsp;<sup>[RW]</sup></strong><br/>
<p>Message text to return on a successful message acceptance. This is
automatically prefixed by “250 2.6.0 ” so you don’t have to care about the
LMTP status code. This text is purely informational and has no meaning to
the protocol. It will show up in the sending MTA’s logs.</p>
</li>
    
  </ul>




                   
   
    
    
    

    <h2 id="public-class-methods">Public Class Methods</h2>

    
      <div class="method public-class" id="method-c-new">
        <div class="header">
          new(path, mode = nil, &callback)
        </div>
        <div class="description">
          
<p>Create a new LMTP server.</p>

<h3 id="method-c-new-label-Parameters">Parameters<span><a href="#method-c-new-label-Parameters">&para;</a> <a href="#top">&uarr;</a></span></h3>
<dl class="rdoc-list label-list"><dt>path
<dd>
<p>Path on which the UNIX domain socket is created. All parent directories
must exist, but the “file” itself must not exist (an ArgumentError is
thrown if it exists).</p>
</dd><dt>mode (nil)
<dd>
<p>UNIX permissions to set on the UNIX socket file as a numeric mode (example:
0666 for rw-rw-rw-). User and Group of the file are determined by whatever
the process environment mandates. <code>nil</code> means to use whatever
the process umask mandates.</p>
</dd><dt>callback
<dd>
<p>Message callback. Receives any email as a string that is passed to this
LMTP server. The string will contain the original carriagereturn+newline
line breaks from the protcol.</p>
</dd></dl>

<h3 id="method-c-new-label-Return+value">Return value<span><a href="#method-c-new-label-Return+value">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Returns the new instance.</p>


          
          <p class="show-source"><a href="#">[Show source]</a></p>
          <pre class="ruby" style="display: none">
<span class="ruby-comment"># File lib/lmtp.rb, line 132</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">mode</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">callback</span>)
  <span class="ruby-ivar">@path</span>     = <span class="ruby-identifier">path</span>
  <span class="ruby-ivar">@mode</span>     = <span class="ruby-identifier">mode</span>
  <span class="ruby-ivar">@hostname</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">read</span>(<span class="ruby-constant">HOSTNAME_FILE</span>).<span class="ruby-identifier">strip</span>
  <span class="ruby-ivar">@msgcb</span>    = <span class="ruby-identifier">callback</span>
  <span class="ruby-ivar">@client</span>   = <span class="ruby-keyword">nil</span>
  <span class="ruby-ivar">@timeout</span>  = <span class="ruby-value">30</span>
  <span class="ruby-ivar">@mutex</span>    = <span class="ruby-constant">Mutex</span>.<span class="ruby-identifier">new</span>
  <span class="ruby-ivar">@do_stop</span>  = <span class="ruby-keyword">false</span>
  <span class="ruby-ivar">@headercb</span> = <span class="ruby-identifier">method</span>(<span class="ruby-value">:default_headercb</span>)
  <span class="ruby-ivar">@moreextensions</span> = []
  <span class="ruby-ivar">@successmsg</span>     = <span class="ruby-string">&quot;All your bytes are belong to us.&quot;</span>

  <span class="ruby-keyword">if</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">exist?</span>(<span class="ruby-identifier">path</span>)
    <span class="ruby-identifier">raise</span>(<span class="ruby-constant">ArgumentError</span>, <span class="ruby-node">&quot;File already exists: #{path}&quot;</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
          </pre>
        </div>
      </div>
    
   
    
    
     
    
    
    
                   
   
    
    
    

    <h2 id="public-instance-methods">Public Instance Methods</h2>

    
      <div class="method public-instance" id="method-i-headers">
        <div class="header">
          headers(&callback)
        </div>
        <div class="description">
          
<p>Override the callback used for responding to the LMTP client for the LMTP
commands before DATA, e.g. MAIL FROM and RCPT TO. The callback receives the
entire line the client sent, including the trailing carriagereturn-newline.</p>

<p>The default callback only answers “250 2.1.0 ok” for every command.  Note
that RFC 2033 (LMTP) requires in section 5 that any LMTP server MUST
implement RFC 2034, which in turn refers to RFC 1893 for the actual status
codes, so for any replies you make you must make use of the extended
statuscodes defined in RFC 1893 in the format defined by RFC 2034. Don’t
worry — both of these RFCs are simple enough to just read quickly through
them.</p>

<p>Example:</p>

<pre class="ruby"><span class="ruby-identifier">server</span>.<span class="ruby-identifier">headers</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span>
  <span class="ruby-keyword">case</span> <span class="ruby-identifier">line</span>
  <span class="ruby-keyword">when</span> <span class="ruby-regexp">/^MAIL FROM/</span> <span class="ruby-keyword">then</span> <span class="ruby-string">&quot;250 ok&quot;</span>
  <span class="ruby-keyword">when</span> <span class="ruby-regexp">/^RCPT TO:&lt;.*?&gt;/</span> <span class="ruby-keyword">then</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">this_account_exists</span>(<span class="ruby-node">$1</span>)
      <span class="ruby-string">&quot;250 2.1.5 Recipient ok&quot;</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-string">&quot;550 5.1.1 Recipient does not exist over here.&quot;</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-string">&quot;250 2.1.0 ok&quot;</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Note that the replies you define here are not immediately sent to the
client, which is a result of the PIPELINING extension that is required by
LMTP (see RFC 2033, section 5, and RFC 1854). Instead they’re accumulated
and send as a big swall to the client when he issues the DATA command.</p>


          
          <p class="show-source"><a href="#">[Show source]</a></p>
          <pre class="ruby" style="display: none">
<span class="ruby-comment"># File lib/lmtp.rb, line 193</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">headers</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">callback</span>)
  <span class="ruby-ivar">@headercb</span> = <span class="ruby-identifier">callback</span>
<span class="ruby-keyword">end</span>
          </pre>
        </div>
      </div>
    
      <div class="method public-instance" id="method-i-logging">
        <div class="header">
          logging(&callback)
        </div>
        <div class="description">
          
<p>Specify the logging callback. It will receive a syslog logging level as a
symbol and the log message.</p>

<p>By default, no logging callback is set and hence nothing is logged.</p>


          
          <p class="show-source"><a href="#">[Show source]</a></p>
          <pre class="ruby" style="display: none">
<span class="ruby-comment"># File lib/lmtp.rb, line 155</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">logging</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">callback</span>)
  <span class="ruby-ivar">@logcb</span> = <span class="ruby-identifier">callback</span>
<span class="ruby-keyword">end</span>
          </pre>
        </div>
      </div>
    
      <div class="method public-instance" id="method-i-start">
        <div class="header">
          start()
        </div>
        <div class="description">
          
<p>Create the UNIX domain socket and start listening on it. This method starts
a listening loop and thus blocks. Use <a
href="LmtpServer.html#method-i-stop">stop</a> from another thread to issue
a halt.</p>


          
          <p class="show-source"><a href="#">[Show source]</a></p>
          <pre class="ruby" style="display: none">
<span class="ruby-comment"># File lib/lmtp.rb, line 205</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">start</span>
  <span class="ruby-identifier">log</span> <span class="ruby-value">:info</span>, <span class="ruby-string">&quot;Starting server&quot;</span>
  <span class="ruby-ivar">@mutex</span>.<span class="ruby-identifier">synchronize</span>{ <span class="ruby-ivar">@do_stop</span> = <span class="ruby-keyword">false</span> }

  <span class="ruby-constant">UNIXServer</span>.<span class="ruby-identifier">open</span>(<span class="ruby-ivar">@path</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">server</span><span class="ruby-operator">|</span>
    <span class="ruby-constant">File</span>.<span class="ruby-identifier">chmod</span>(<span class="ruby-ivar">@mode</span>, <span class="ruby-ivar">@path</span>) <span class="ruby-keyword">if</span> <span class="ruby-ivar">@mode</span>

    <span class="ruby-identifier">log</span> <span class="ruby-value">:info</span>, <span class="ruby-string">&quot;Accepting connections.&quot;</span>
    <span class="ruby-keyword">while</span> <span class="ruby-ivar">@client</span> = <span class="ruby-identifier">server</span>.<span class="ruby-identifier">accept</span>
      <span class="ruby-identifier">addr</span> = <span class="ruby-ivar">@client</span>.<span class="ruby-identifier">addr</span>.<span class="ruby-identifier">last</span>
      <span class="ruby-identifier">log</span> <span class="ruby-value">:info</span>, <span class="ruby-node">&quot;Client connect from #{addr}.&quot;</span>

      <span class="ruby-comment"># TODO: Use #accept_nonblock in loop? This way, a client has to connect</span>
      <span class="ruby-comment"># first to have the server shut down.</span>
      <span class="ruby-keyword">break</span> <span class="ruby-keyword">if</span> <span class="ruby-ivar">@mutex</span>.<span class="ruby-identifier">synchronize</span>{ <span class="ruby-ivar">@do_stop</span> }

      <span class="ruby-keyword">begin</span>
        <span class="ruby-identifier">catch</span> <span class="ruby-value">:timeout</span> <span class="ruby-keyword">do</span>
          <span class="ruby-identifier">handle_client</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">rescue</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">e</span>
        <span class="ruby-identifier">log</span> <span class="ruby-value">:err</span>, <span class="ruby-node">&quot;Exception: #{e.class.name}: #{e.message}: #{e.backtrace.join(&quot;\n&quot;)}&quot;</span>
        <span class="ruby-identifier">log</span> <span class="ruby-value">:err</span>, <span class="ruby-string">&quot;Aborting connection due to exception.&quot;</span>
        <span class="ruby-ivar">@client</span>.<span class="ruby-identifier">close</span>
      <span class="ruby-keyword">end</span>

      <span class="ruby-identifier">log</span> <span class="ruby-value">:info</span>, <span class="ruby-node">&quot;Client connection closed: #{addr}&quot;</span>
      <span class="ruby-ivar">@client</span> = <span class="ruby-keyword">nil</span>
    <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">log</span> <span class="ruby-value">:info</span>, <span class="ruby-string">&quot;Server stopped.&quot;</span>
<span class="ruby-keyword">ensure</span>
  <span class="ruby-keyword">if</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">exist?</span>(<span class="ruby-ivar">@path</span>)
    <span class="ruby-identifier">log</span> <span class="ruby-value">:info</span>, <span class="ruby-node">&quot;Removing UNIX socket &#39;#@path&#39;&quot;</span>
    <span class="ruby-constant">File</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-ivar">@path</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
          </pre>
        </div>
      </div>
    
      <div class="method public-instance" id="method-i-stop">
        <div class="header">
          stop()
        </div>
        <div class="description">
          
<p>Halt the running server. This method is threadsafe.</p>


          
          <p class="show-source"><a href="#">[Show source]</a></p>
          <pre class="ruby" style="display: none">
<span class="ruby-comment"># File lib/lmtp.rb, line 198</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">stop</span>
  <span class="ruby-ivar">@mutex</span>.<span class="ruby-identifier">synchronize</span>{ <span class="ruby-ivar">@do_stop</span> = <span class="ruby-keyword">true</span> }
<span class="ruby-keyword">end</span>
          </pre>
        </div>
      </div>
    
   
    
    
     
    
    
    


      <div id="footer">
        <p style="width: 49%; float: left">Time: 2015-05-26 19:02:59 +0200</p>
        <p style="width: 49%; float: right; text-align: right">
          Generated by the
          <a href="https://github.com/Quintus/emerald">Emerald generator for RDoc</a>.
        </p>
      </div>
    </div>

    <div class="clear"></div>
  </body>
</html>
